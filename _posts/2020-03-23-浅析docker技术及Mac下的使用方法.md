---
layout:     post
title:      浅析docker技术及Mac下的使用方法
subtitle:   容器
date:       2020-03-22
author:     matrix
header-img: img/dockerfirst.jpeg
catalog: true
tags:
    - Docker

---

学习过程中认识到docker的便利和轻量化，避免了虚拟机的笨重，所以借此机会加深学习，遂有此文。

事实上docker源于容器，所以，我们从容器说起。

## 容器

一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。

- 容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。
- 容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。
- 容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。

## 虚拟机与容器

物理机是相对于虚拟机的称呼，它包含了我们计算机运行所需的硬件环境，即计算机最开始的样子。虚拟机则是在物理机的基础上，从物理机上划分出自己所需的硬件环境，运行一套完整的操作系统。**容器与虚拟机的不同之处在于其虚拟的并非硬件环境，而是操作系统，即在宿主操作系统上虚拟出一个操作系统。**

**所以虚拟操作系统是什么意思？宿主如果和容器系统不同的话，那不是和虚拟机一样吗，一层层的调用，那么容器和虚拟机还有什么差别？**

首先要把 Windows 和 Linux 分清楚，更要把**内核(kernel)**和**用户空间(userland)**分清楚。

容器内的进程是直接运行于宿主内核的，这点和宿主进程一致，只是容器的 userland 不同，容器的 userland 由容器镜像提供，也就是说镜像提供了 **rootfs(根文件系统)**。

**假设宿主是 Ubuntu，容器是 CentOS。CentOS 容器中的进程会直接向 Ubuntu 宿主内核发送 syscall(即系统调用， system call，它是在用户空间和内核空间之间的中间层，是连接用户态和内核态的桥梁)，而不会直接或间接的使用任何 Ubuntu 的 userland 的库。**

这点和虚拟机有本质的不同，虚拟机是虚拟环境，在现有系统上虚拟一套物理设备，然后在虚拟环境内运行一个虚拟环境的操作系统内核，在内核之上再跑完整系统，并在里面调用进程。

还以上面的例子去考虑，**虚拟机中，CentOS 的进程发送 syscall 内核调用，该请求会被虚拟机内的 CentOS 的内核接到，然后 CentOS 内核访问虚拟硬件时，由虚拟机的服务软件截获，并使用宿主系统，也就是 Ubuntu 的内核及 userland 的库去执行**。

而且，Linux 和 Windows 在这点上非常不同。Linux 的进程是直接发 syscall 的，而 Windows 则把 syscall 隐藏于一层层的 DLL 服务之后，因此 Windows 的任何一个进程如果要执行，不仅仅需要 Windows 内核，还需要一群服务来支撑，所以如果 Windows 要实现类似的机制，容器内将不会像 Linux 这样轻量级，而是非常臃肿。看一下微软移植的 Docker 就非常清楚了。

所以不要把 容器和虚拟机弄混， 容器只是一个进程而已，只不过利用镜像提供的 rootfs 提供了调用所需的 userland 库支持，使得进程可以在受控环境下运行而已，它并没有虚拟出一个机器出来。

![]({{site.baseurl}}/img/virtualmachines.png)

![]({{site.baseurl}}/img/docker.png)

容器与虚拟机是可以共存的。

![]({{site.baseurl}}/img/compare.png)

## Docker是什么？为什么要用Docker？

#### Docker是什么

Docker是一个让开发者构建和运行应用程序的平台，也叫做软件容器平台。Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案，其诞生与2013年初，后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在[GitHub](https://github.com/docker/docker) 上进行维护。项目代码在GitHub上进行维护。

Docker最初基于LXC（Linux container）技术，进行了进一步的封装，让用户不需要去关心容器的管理。

`Docker client`和`Docker daemon`是Docker Engine的一部分，它是现在在Mac上运行的客户端 - 服务器应用程序。 `daemon`是服务器，客户端是docker命令行界面`（CLI）`。 客户端使用引擎的`REST API`向`daemon`发出指令。

##### **Docker容器的特点**

- 轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。
- 标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。
- 安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。

##### **Docker是如何实现应用隔离的 ？**

docker是容器，它将所有的访问文件和操作系统的api重新定向了，让应用内感觉自己在一个独立的操作系统上运行，而docker拦截了api调用，并且把那些全局的对操作系统的访问进行了包装，使得程序不会真的访问它们。

##### **Docker是如何跨平台的 ？**

在mac下运行docker实际上是先开启了一个linux虚拟机，然后在虚拟机上运行docker。

![]({{site.baseurl}}/img/docker2.jpeg)

#### 为什么要用Docker

**更高效的利用系统资源**

由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高，无论是应用执行速度，内存消耗以及文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。

**更快速的启动时间**

传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行与宿主内核，无序启动完整的操作系统，因此可以做到妙级，甚至毫秒级的启动时间，大大的节约了开发，测试，部署的时间。

**一致的运行环境**

开发过程中一个常见的问题是环境一致性问题，由于开发环境，测试环境，生产环境不一致，导致有些bug并未在开发过程中被发现，而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。从而不会再出现（这段代码在我机器上运行没问题啊）zz这类问题。

**持续交付和部署**

对于开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。

使用Docker可以通过定制应用镜像来实现持续集成，持续交付，部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试，而运维人员则可以在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署

**更轻松的迁移**

由于Docker确保了执行环境的一致性，使得应用的迁移更加容易，Docker可以在很多平台上运行，无论是物理机，虚拟机，公有云，私有云，甚至是笔记本，其运行结果是一致的，因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。

**更轻松的维护和扩展**

Docker使用的分层存数以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单，此外，Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。

**更快速的交付和部署**

对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。

开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。

**更高效的虚拟化**

Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。

**更简单的管理**

使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。

## Docker的三个基本概念



#### 镜像（Image）——一个特殊的文件系统

操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。

操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。

Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。

Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。

镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。

#### 容器（Container）——镜像运行时的实体

**容器 - 一个位于镜像只读层顶部的精简读写层**

镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。

容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。

按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。

#### 仓库（Repository）——集中存放镜像文件的地方

镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。

一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。

通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过<仓库名>:<标签>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。

这里补充一下Docker Registry公开服务和私有Docker Registry的概念：

Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。

最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。

除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。

## 使用Docker搭建nginx服务器

此处略过Docker安装。

另外，macos自带apache web 服务器，只需要通过以下命令使用即可

```
sudo apachectl start //开启apache
sudo apachectl restart //重启apache
sudo apachectl stop //关闭apache
```

打开finder，command+shift+g，前往下述路径，/Library/WebServer/Documents，即mac下apache服务器的文件路径。把我们的web项目代码放到这个路径下，就可以在浏览器打开了～

#### 拉取镜像

首先可以使用`docker search nginx` 查询有哪些关于nginx 的镜像。我们可以看到第一个即为官方镜像。

![]({{site.baseurl}}/img/dockersearch.png)

`docker run --name nginx -d -p 80:80 nginx` 从官方镜像注册表拉取最新版nginx

| 参数         | 作用                                               |
| ------------ | -------------------------------------------------- |
| -i           | 以交互模式运行容器，通常与 -t 同时使用；           |
| -t           | 为容器重新分配一个伪输入终端，通常与 -i 同时使用； |
| -d           | 后台运行容器，并返回容器ID；                       |
| --name nginx | 该参数指定容器实例的名字                           |
| -p 80:80     | 指定要映射的IP和端口,hostPort:containerPort        |
| -P           | 随机映射主机端口                                   |

`docker rm -f mynginx` 可以直接删除容器

` Docker ps`  查看运行中的容器

`docker exec -it mynginx /bin/bash` 在运行的容器中执行命令/bin/bash,打开一个交互模式终端

![]({{site.baseurl}}/img/dockerexec.png)Nginx安装在usr/lib/nginx下，配置在etc/nginx下面，包括nginx.conf主配置文件，conf.d和site-enabled是附加的配置文件。后面，我们将会该目录映射到宿主机目录，以便于修改和管理。

#### 网站开发

在宿主机建立一个目录app，然后将其映射到容器nginx的/usr/share/nginx/html目录。/usr/share/nginx目录在容器的默认配置文件/etc/nginx/conf.d/default.conf中已经将/usr/share/nginx/html设为网站根目录了。

设置文件夹映射

` docker run --name mynginx -d -p 80:80  -v /Users/matrix/nginx/app:/usr/share/nginx/html  nginx` 

在/Users/matrix/nginx/app下创建一个index.html文件

访问http://localhost:80

![]({{site.baseurl}}/img/itworks.png)

` docker logs mynginx ` 可以查看刚刚的web日志

![]({{site.baseurl}}/img/dockerlogs.png)

` docker container list -a ` 可以查看容器的md5值

![]({{site.baseurl}}/img/containerlist.png)

进入容器也可使用md5值：` docker exec -it 527 bash` 

#### 建立配置文件映射

使用将容器中的默认配置文件映射到宿主机中即可

` docker run --name nginx -d -p 80:80  -v /Users/matrix/nginx/app:/usr/share/nginx/html -v /Users/matrix/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf nginx` 

## Docker容器安全管控

后续增加！

> 参考链接：
>
> http://dockone.io/article/6051
>
> https://www.jianshu.com/p/3bfa8d09bc8b
>
> https://blog.csdn.net/chudelong1/article/details/86540591
>
> https://mp.weixin.qq.com/s/TFqX4IVjbQN_mxeoLbtIrw
>
> 官方文档https://docs.docker.com
>
> https://hub.docker.com
>
> 根文件系统（rootfs）https://www.cnblogs.com/kelamoyujuzhen/p/11541495.html