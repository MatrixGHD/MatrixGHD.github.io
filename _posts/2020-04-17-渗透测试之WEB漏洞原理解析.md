---
layout:     post
title:      WEB漏洞原理解析
subtitle:   渗透测试文章（1）
date:       2020-04-17
author:     matrix
header-img: img/websecurity.jpeg
catalog: true
tags:
    - 渗透测试
---
[toc]
## 一、SQL注入

#### 1.1 原理

SQL注入就是WEB应用程序对用户输入数据的合法性没有判断，前端传入的参数是攻击者可控的，并且参数被带入数据库查询，攻击者可以构造不同的SQL语句来执行数据库的操作。                                                      注意其中的两个条件：参数用户可控；参数带入数据库查询。

#### 1.2 类型

SQL注入一般可分为以下几种：union注入、布尔注入、时间注入、堆叠查询注入、二次注入、宽字节注入、cookie注入、base64注入、XFF注入

#### 1.3 SQL注入绕过技术

大小写绕过、双写绕过、编码绕过、内联注释绕过

#### 1.4 SQL注入漏洞修复建议

##### 1.4.1 过滤危险字符

如采用正则表达式匹配union、sleep、load_file等关键字，如果匹配到则报错或退出程序，存在被绕过风险。

##### 1.4.2 使用预编译语句

通常我们的一条sql在db接收到最终执行完毕返回可以分为下面三个过程：

（1）词法和语义解析；（2）优化sql语句，制定执行计划；（3）执行并返回结果

我们把这种普通语句称作**Immediate Statements**。

但是很多情况，我们的一条sql语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。

所谓预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句模板化或者说参数化，一般称这类语句叫**Prepared Statements**或者**Parameterized Statements**。
预编译语句的优势在于归纳为：**一次编译、多次运行，省去了解析优化等过程**， 因此也被用来防止SQL注入



## 二、XSS跨站脚本攻击

#### 2.1 原理

跨站脚本攻击（XSS）是一种代码注入技术，它允许攻击者将代码注入网页，导致其它访问者在浏览网页时会受到影响。攻击者将获得其他访问者的权限、私密网页内容、会话、cookie等各种内容。

#### 2.2 类型

##### 2.2.1 反射型XSS

反射型XSS即一次性XSS攻击、非持久型XSS。

攻击方式：攻击者通过社交软件或邮件等形式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS代码的数据发送到目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。

##### 2.2.2 存储型XSS

存储型XSS即持久型XSS，XSS脚本永久存储在目标服务器的数据库或文件中。

攻击方式：这种攻击多见于论坛、博客和留言板，攻击者在发帖过程中将恶意代码和正常信息一起注入帖子的内容中，导致恶意代码被永久保存在服务器的后端存储器中。当其他用户浏览这个恶意帖子时，恶意脚本就会在他们的浏览器中执行。

##### 2.2.3 DOM型XSS

DOM（document object model），使用DOM可以使程序和脚本能够动态访问和更新文档的内容、结构和样式。DOM型XSS是一种特殊类型的XSS攻击，它基于DOM文档对象模型。DOM即网站页面返回到浏览器时，浏览器为页面创建的文档对象，包含网页里的所有元素，改文档对象可以被JS脚本编辑，从而修改页面的元素，只在客户端执行，不需要与服务器交互。

攻击方式：用户请求一个经过专门设计的URL，它有攻击者提交，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，引发攻击。

#### 2.3 XSS漏洞修复建议

因为XSS漏洞设计输入和输出两部分，所以西叙福也分为两种：

（1）过滤输入的数据，“ ‘ ”、“ “ ”、” < “、“ > ”、“ om* ”等非法字符。

（2）对输出到页面的数据进行编码转换，包括HTML实体编码，Javascript编码等。

## 三、CSRF跨站请求伪造

#### 3.1 原理

跨站请求伪造即通过伪装成受信任用户请求受信任的网站，执行非法操作，比如发邮件、发信息、修改密码、购买商品、转账等。攻击者并没有获取目标用户的cookie和相关信息。

例如：浏览器访问web服务器A，登录状态下存在相应的cookie信息，再用同一个浏览器访问了恶意web服务器B，服务器B返回给浏览器的页面中含有要求访问服务器A的恶意代码，用户不知情的情况下点击后，导致服务器A接收到来自服务器B的通过浏览器发起的恶意请求

#### 3.2 CSRF漏洞的修复建议

（1）验证请求的Rerferer值，若referer是其它网站或空白，就有可能是CSRF攻击。
（2）在HTTP中以参数的形式加入一个随机产生的token，并在服务器端验证token。
（3）关键请求增加验证码
#### 3.3 Burpsuite 测试CSRF漏洞
##### 3.3.1 访问DVWA的CSRF测试页面
可知，该网站功能为输入要修改的密码，提交后，修改成功则返回"Password changed"信息。
![](/img/16047549956245.png)
##### 3.3.2 burp抓去页面请求
重新访问网站，开启浏览器代理，网站页面中填入数据，burpsuite抓取页面请求数据
![](/img/16047549848669.png)
![](/img/16047549700634.png)
##### 3.3.3 生成POC
将BP抓取到的数据包转至Repeater，然后在Repeater界面 “右键—>Engagement tools—>Generate CSRF POC”，即可生成POC
![](/img/16047549354310.png)
![](/img/16047549424195.png)
##### 3.3.4 复制POC URL
在弹出的CSRF Poc generater页面，点击"Test in browser—>Copy"，复制生成的URL
![](/img/16047549192284.png)
##### 3.3.5 访问恶意URL
打开刚才访问目标网站A的浏览器（注意不能关闭原来登录网站A的TAB页面，此时也不能关闭代理），新建一个TAB页面，粘贴刚才在BP中复制的URL，访问得到如下页面
![](/img/16047549049204.png)
![](/img/16047548928588.png)
原理： 此时Burpsuite生成了一个POC（一个HTML页面），并将自己作为一个web服务器（恶意Web服务器B），浏览器通过生成的URL即可访问页面，按F12查看源码，可以看到就是Burpsuite生成的HTML，源码如下：
```shell
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <!--注释：将form表单中的数据提交到 http://127.0.0.1:8002/vulnerabilities/csrf/-->
  <script>history.pushState('', '', '/')</script>
    <form action="http://127.0.0.1:8002/vulnerabilities/csrf/">
      <input type="hidden" name="password&#95;new" value="1234" />
      <input type="hidden" name="password&#95;conf" value="1234" />
      <input type="hidden" name="Change" value="Change" />
      <input type="submit" value="Submit request" />
    </form>
  </body>
</html>
```
这是一个HTML表单，功能是在点击"Submit request"按钮后，将表单数据提交至http://127.0.0.1:8002/vulnerabilities/csrf/，也就是提交至可信任服务器。若可信任服务器正常响应这个请求，说明漏洞利用成功。
注： Burpsuite端口为8080，浏览器只有在开启代理时才能直接通过域名URL访问到该服务器，或者也可以关闭代理，将BP生成的URL中的http://burp/用http://127.0.0.1:8080/替换即可
##### 3.3.6 提交恶意请求
关闭浏览器代理，然后点击网页中的"Submit request"，得到返回页面"Password changed"，说明漏洞利用成功，网站存在CSRF漏洞。
![](/img/16047548633492.png)
![](/img/16047548562365.png)
注： 关闭代理的原因，表单是提交至DVWA的服务器，如果不关闭代理，数据将被burpsuite拦截，也可以在burpsuite中将拦截到的数据直接转发出去，查看在burpsuite中查看DVWA的响应数据包即可。
## 四、SSRF服务器端请求伪造

#### 4.1 原理

服务器端请求伪造，攻击者构造的由服务器发起的请求，一般对象是内部系统，其形成大多数是由于服务端提供了从其它服务器应用获取数据的功能并没有对目标地址做过滤与限制。如访问内部服务器上的文件、数据库服务器等。

#### 4.2 SSRF漏洞修复建议

（1）限制请求的端口只能为web端口，只允许访问HTTP和HTTPS的请求。

（2）限制不能访问哪网的IP，以防止对内网的攻击。

（3）屏蔽返回的详细信息。

## 五、文件上传漏洞

#### 5.1 原理

由于服务端代码未对上传的文件进行严格验证和过滤，攻击者将可执行脚本上传到服务器中，获得网站的权限，获取进一步危害服务器。这个恶意脚本文件又被称为webshell。

#### 5.2 文件上传漏洞修复建议

（1）白名单判断文件后缀是否合法；（2）对上传的文件进行重命名

## 六、暴力破解漏洞

#### 6.1 原理

由于服务端没有对请求频率做限制，导致攻击者可破解用户名、密码、验证码等信息。

#### 6.2 暴力破解漏洞修复建议

（1）设定登陆次数阈值，超过阈值锁定账号；（2）设定一个IP的可登陆次数阈值，超过阈值锁定IP

## 七、命令执行漏洞

#### 7.1 原理

应用程序需要调用包含系统命令的函数，如PHP中的system、exec、shell_exec、passthru等函数。攻击者可将系统命令拼接到正常命令中，执行系统命令。

#### 7.2 命令执行漏洞修复建议

（1）尽量不使用命令执行函数；（2）做好过滤和检测；（3）白名单限制制定动态函数

## 八、逻辑漏洞

#### 8.1 原理

逻辑漏洞即业务系统设计缺陷。一般存在于密码修改、密码找回、越权访问等功能处。包括水平越权和垂直越权。

#### 8.2 逻辑漏洞修复建议

通过session控制用户的身份，将用户ID或username写入到session中。

## 九、XXE漏洞

#### 9.1 原理

XXE即XML外部实体注入漏洞，代码没有限制XML引入外部实体，当攻击者创建一个包含外部实体的XML时，外部实体的内容就会被执行。XML 指可扩展标记语言（EXtensible Markup Language），用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。

XML 与 HTML 的主要差异：XML 不是 HTML 的替代，XML 被设计为传输和存储数据，其焦点是数据的内容，HTML 被设计用来显示数据，其焦点是数据的外观，HTML 旨在显示信息，而 XML 旨在传输信息。

#### 9.2 XXE漏洞修复建议

（1）禁止使用外部实体；（2）过滤用户提交的XML数据，防止出现非法内容